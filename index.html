<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿è¿çœ‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 10px;
        }
        
        .header h1 {
            font-size: 2em;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .footer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
        }
        
        .version-btn {
            background: rgba(255,255,255,0.25);
            border: 1px solid rgba(255,255,255,0.5);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
            backdrop-filter: blur(5px);
        }
        
        .version-btn:hover {
            background: rgba(255,255,255,0.35);
            transform: scale(1.05);
        }
        
        .info-bar {
            display: flex;
            gap: 20px;
            justify-content: center;
            color: white;
            font-size: 1.1em;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .info-item {
            background: rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 20px;
        }
        
        .game-container {
            background: white;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 100%;
            overflow: auto;
        }
        
        .game-board-wrapper {
            display: flex;
            justify-content: center;
        }
        
        .game-board {
            display: grid;
            gap: 1px;
            position: relative;
            width: min(90vw, 90vh, 500px);
            height: min(90vw, 90vh, 500px);
            margin: 0 auto;
        }
        
        .cell {
            background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(min(90vw, 90vh, 500px) / (var(--cols, 8) + 2) * 0.85);
            transition: all 0.2s ease;
            box-shadow: 2px 2px 4px rgba(0,0,0,0.1), -2px -2px 4px rgba(255,255,255,0.8);
        }
        
        .cell:hover {
            transform: scale(1.05);
        }
        
        .cell.selected {
            background: linear-gradient(145deg, #ffeb3b, #ffc107);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
            animation: pulse 0.5s ease-in-out;
        }
        
        .cell.matched {
            opacity: 0;
            pointer-events: none;
        }
        
        .cell.empty {
            background: transparent;
            box-shadow: none;
            cursor: default;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .line {
            position: absolute;
            background: #4CAF50;
            border-radius: 3px;
            z-index: 10;
            pointer-events: none;
            animation: drawLine 0.3s ease-out;
        }
        
        @keyframes drawLine {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 25px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .btn-primary {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(145deg, #f093fb, #f5576c);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 90%;
            animation: popIn 0.3s ease-out;
        }
        
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .modal-content h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 2em;
        }
        
        .modal-content p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.2em;
        }
        
        .difficulty-select {
            margin-bottom: 15px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            margin: 5px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .difficulty-btn.active,
        .difficulty-btn:hover {
            background: #667eea;
            color: white;
        }
        
        @media (max-width: 500px) {
            .header h1 {
                font-size: 1.3em;
            }
            
            .version-btn {
                padding: 6px 12px;
                font-size: 0.85em;
            }
            
            .info-bar {
                font-size: 0.8em;
                gap: 10px;
            }
            
            .info-item {
                padding: 5px 10px;
                font-size: 0.9em;
            }
            
            .game-container {
                padding: 6px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9em;
            }
            
            .modal-content {
                padding: 20px;
            }
            
            .difficulty-btn {
                padding: 8px 15px;
                font-size: 0.9em;
            }
        }
        
        @media (max-width: 380px) {
            .header h1 {
                font-size: 1.1em;
            }
            
            .version-btn {
                padding: 5px 10px;
                font-size: 0.75em;
            }
            
            .info-bar {
                font-size: 0.7em;
                gap: 8px;
            }
            
            .info-item {
                padding: 4px 8px;
            }
            
            .controls {
                gap: 8px;
            }
            
            .btn {
                padding: 8px 15px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® è¿è¿çœ‹</h1>
    </div>
    
    <div class="info-bar">
        <div class="info-item">â±ï¸ æ—¶é—´ï¼š<span id="time">0</span>ç§’</div>
        <div class="info-item">ğŸ”„ æ­¥æ•°ï¼š<span id="moves">0</span></div>
        <div class="info-item">ğŸ’¯ åˆ†æ•°ï¼š<span id="score">0</span></div>
    </div>
    
    <div class="game-container">
        <div class="game-board-wrapper">
            <div class="game-board" id="board"></div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn btn-primary" onclick="showNewGameModal()">ğŸ”„ æ–°æ¸¸æˆ</button>
        <button class="btn btn-secondary" onclick="shuffleBoard()">ğŸ”€ æ‰“ä¹±</button>
    </div>
    
    <div class="modal" id="winModal">
        <div class="modal-content">
            <h2>ğŸ‰ æ­å–œè·èƒœï¼</h2>
            <p>ç”¨æ—¶ï¼š<span id="finalTime">0</span>ç§’<br>æ­¥æ•°ï¼š<span id="finalMoves">0</span><br>å¾—åˆ†ï¼š<span id="finalScore">0</span></p>
            <button class="btn btn-primary" onclick="closeModal(); startNewGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>
    
    <div class="modal" id="newGameModal">
        <div class="modal-content">
            <h2>ğŸ® æ–°æ¸¸æˆ</h2>
            <div class="difficulty-select">
                <button class="difficulty-btn active" onclick="setDifficulty('easy')">ç®€å•</button>
                <button class="difficulty-btn" onclick="setDifficulty('medium')">ä¸­ç­‰</button>
                <button class="difficulty-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
            </div>
            <button class="btn btn-primary" onclick="confirmNewGame()">å¼€å§‹æ¸¸æˆ</button>
        </div>
    </div>
    
    <div class="modal" id="versionModal">
        <div class="modal-content">
            <h2>ğŸ“‹ ç‰ˆæœ¬ä¿¡æ¯</h2>
            <p><strong>å½“å‰ç‰ˆæœ¬:</strong> v1.4.3</p>
            <p><strong>æ›´æ–°æ—¶é—´:</strong> 2026-02-27</p>
            <hr style="margin: 15px 0; border: none; border-top: 1px solid #ddd;">
            <p><strong>æ›´æ–°å†…å®¹:</strong></p>
            <ul style="text-align: left; margin-left: 20px; line-height: 1.8;">
                <li>ä¼˜åŒ–å›¾æ ‡åˆ†å¸ƒç®—æ³•ï¼Œè®©å›¾æ ‡æ›´åˆ†æ•£</li>
                <li>ä¿®å¤æ‰‹æœºç«¯è¿çº¿ä»ä¸­å¿ƒå‡ºå‘çš„é—®é¢˜</li>
                <li>æ·»åŠ ç‰ˆæœ¬æŸ¥çœ‹åŠŸèƒ½</li>
                <li>ä¼˜åŒ–æ£‹ç›˜è‡ªé€‚åº”å±å¹•å¤§å°</li>
                <li>å°†ç‰ˆæœ¬æŒ‰é’®ç§»è‡³é¡µé¢åº•éƒ¨ï¼Œä¼˜åŒ–ç§»åŠ¨ç«¯ä½“éªŒ</li>
                <li>ä¿®å¤æ‰“ä¹±æŒ‰é’® bugï¼Œä¿æŒåŸæœ‰å›¾æ ‡ä¸å˜ä»…é‡æ–°æ’åˆ—</li>
                <li>ç®€å•éš¾åº¦è°ƒæ•´ä¸º 4Ã—4 ç½‘æ ¼</li>
                <li>å½»åº•ä¿®å¤æ‰“ä¹±æŒ‰é’®å¯¼è‡´å›¾æ ‡æ¶ˆå¤±çš„ä¸¥é‡ bug</li>
            </ul>
            <button class="btn btn-primary" onclick="hideVersion()" style="margin-top: 15px;">ç¡®å®š</button>
        </div>
    </div>

    <script>
        const emojis = ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ«', 'ğŸ’', 'ğŸ‘', 'ğŸ¥­', 'ğŸ', 'ğŸ¥¥', 'ğŸ¥', 'ğŸ…', 'ğŸ¥‘'];
        
        let board = [];
        let rows = 8;
        let cols = 8;
        let selectedCell = null;
        let time = 0;
        let moves = 0;
        let score = 0;
        let timer = null;
        let gameActive = false;
        let currentDifficulty = 'easy';
        
        const difficultySettings = {
            easy: { rows: 4, cols: 4 },
            medium: { rows: 6, cols: 8 },
            hard: { rows: 8, cols: 10 }
        };
        
        function init() {
            createBoard();
            startTimer();
            gameActive = true;
        }
        
        function showNewGameModal() {
            document.getElementById('newGameModal').classList.add('show');
        }
        
        function setDifficulty(level) {
            currentDifficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === (level === 'easy' ? 'ç®€å•' : level === 'medium' ? 'ä¸­ç­‰' : 'å›°éš¾')) {
                    btn.classList.add('active');
                }
            });
        }
        
        function confirmNewGame() {
            document.getElementById('newGameModal').classList.remove('show');
            startNewGame();
        }
        
        function closeModal() {
            document.getElementById('winModal').classList.remove('show');
        }
        
        function showVersion() {
            document.getElementById('versionModal').classList.add('show');
        }
        
        function hideVersion() {
            document.getElementById('versionModal').classList.remove('show');
        }
        
        function startNewGame() {
            stopTimer();
            const settings = difficultySettings[currentDifficulty];
            rows = settings.rows;
            cols = settings.cols;
            board = [];
            selectedCell = null;
            time = 0;
            moves = 0;
            score = 0;
            updateInfo();
            createBoard();
            startTimer();
            gameActive = true;
        }
        
        function createBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${cols + 2}, 1fr)`;
            boardEl.style.setProperty('--cols', cols);
            
            // åˆå§‹åŒ–ç©ºæ£‹ç›˜ï¼ˆè¾¹ç•Œä¸ºç©ºï¼‰
            for (let r = 0; r < rows + 2; r++) {
                board[r] = [];
                for (let c = 0; c < cols + 2; c++) {
                    board[r][c] = null;
                }
            }
            
            // æ”¶é›†æ‰€æœ‰å¯æ”¾ç½®çš„ä½ç½®ï¼ˆä¸åŒ…æ‹¬è¾¹ç•Œï¼‰
            let positions = [];
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    positions.push({r, c});
                }
            }
            
            // è®¡ç®—éœ€è¦å¤šå°‘å¯¹
            const totalPairs = Math.floor(positions.length / 2);
            
            // ç”Ÿæˆæˆå¯¹çš„å›¾æ ‡
            let iconPairs = [];
            for (let i = 0; i < totalPairs; i++) {
                const emoji = emojis[i % emojis.length];
                iconPairs.push([emoji, emoji]);
            }
            
            // æ‰“ä¹±å›¾æ ‡å¯¹é¡ºåº
            for (let i = iconPairs.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [iconPairs[i], iconPairs[j]] = [iconPairs[j], iconPairs[i]];
            }
            
            // æ‰“ä¹±ä½ç½®é¡ºåº
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }
            
            // å¡«å……ä½ç½® - ä½¿ç”¨é—´éš”ç­–ç•¥è®©å›¾æ ‡åˆ†å¸ƒæ›´åˆ†æ•£
            let filledPositions = new Set();
            let pairIdx = 0;
            
            // ç¬¬ä¸€è½®ï¼šæ¯éš”ä¸€ä¸ªä½ç½®æ”¾ä¸€å¯¹ï¼Œç¡®ä¿åˆ†æ•£
            for (let step = 0; step < positions.length && pairIdx < totalPairs; step += 2) {
                const pos1 = positions[step];
                if (filledPositions.has(`${pos1.r},${pos1.c}`)) continue;
                
                // æ‰¾ä¸€ä¸ªä¸ç›¸é‚»çš„ç©ºä½
                let pos2 = null;
                for (const other of positions) {
                    const key = `${other.r},${other.c}`;
                    if (!filledPositions.has(key)) {
                        // æ£€æŸ¥æ˜¯å¦ç›¸é‚»ï¼ˆåŒ…æ‹¬å¯¹è§’çº¿ï¼‰
                        const isAdjacent = Math.abs(other.r - pos1.r) <= 1 && 
                                          Math.abs(other.c - pos1.c) <= 1;
                        if (!isAdjacent) {
                            pos2 = other;
                            break;
                        }
                    }
                }
                
                if (pos2) {
                    board[pos1.r][pos1.c] = iconPairs[pairIdx][0];
                    board[pos2.r][pos2.c] = iconPairs[pairIdx][1];
                    filledPositions.add(`${pos1.r},${pos1.c}`);
                    filledPositions.add(`${pos2.r},${pos2.c}`);
                    pairIdx++;
                }
            }
            
            // ç¬¬äºŒè½®ï¼šå¦‚æœè¿˜æœ‰å‰©ä½™ä½ç½®ï¼Œä»»æ„é…å¯¹å¡«å……
            let remainingPositions = positions.filter(p => !filledPositions.has(`${p.r},${p.c}`));
            while (remainingPositions.length >= 2 && pairIdx < totalPairs) {
                const pos1 = remainingPositions.pop();
                const pos2 = remainingPositions.pop();
                board[pos1.r][pos1.c] = iconPairs[pairIdx][0];
                board[pos2.r][pos2.c] = iconPairs[pairIdx][1];
                pairIdx++;
            }
            
            // æ¸²æŸ“æ£‹ç›˜
            for (let r = 0; r < rows + 2; r++) {
                for (let c = 0; c < cols + 2; c++) {
                    const cell = document.createElement('button');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (board[r][c] === null) {
                        cell.classList.add('empty');
                    } else {
                        cell.textContent = board[r][c];
                        cell.onclick = () => handleCellClick(r, c, cell);
                    }
                    
                    boardEl.appendChild(cell);
                }
            }
        }
        
        function shuffleBoard() {
            if (!gameActive) return;
            
            // æ”¶é›†æ‰€æœ‰å‰©ä½™çš„å›¾æ ‡
            let remainingIcons = [];
            
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    if (board[r][c] !== null) {
                        remainingIcons.push(board[r][c]);
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰å‰©ä½™å›¾æ ‡æˆ–æ— æ³•é…å¯¹ï¼Œç›´æ¥è¿”å›
            if (remainingIcons.length < 2 || remainingIcons.length % 2 !== 0) {
                return;
            }
            
            // æ‰“ä¹±å›¾æ ‡é¡ºåº
            for (let i = remainingIcons.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [remainingIcons[i], remainingIcons[j]] = [remainingIcons[j], remainingIcons[i]];
            }
            
            // æ¸…ç©ºä¸­é—´åŒºåŸŸ
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    board[r][c] = null;
                }
            }
            
            // ç”Ÿæˆæ‰€æœ‰å¯ç”¨ä½ç½®å¹¶æ‰“ä¹±
            let allPositions = [];
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    allPositions.push({r, c});
                }
            }
            
            // æ‰“ä¹±ä½ç½®é¡ºåº
            for (let i = allPositions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
            }
            
            // ä¾æ¬¡å°†æˆå¯¹çš„å›¾æ ‡æ”¾åˆ°ä½ç½®ä¸Š
            let pairIdx = 0;
            const totalPairs = remainingIcons.length / 2;
            
            while (pairIdx < totalPairs && allPositions.length >= 2) {
                const pos1 = allPositions.pop();
                const pos2 = allPositions.pop();
                
                board[pos1.r][pos1.c] = remainingIcons[pairIdx * 2];
                board[pos2.r][pos2.c] = remainingIcons[pairIdx * 2 + 1];
                
                pairIdx++;
            }
            
            // æ›´æ–°æ˜¾ç¤º
            renderBoard();
            selectedCell = null;
        }
        
        function renderBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                
                if (board[r][c] === null) {
                    cell.textContent = '';
                    cell.classList.add('empty');
                    cell.classList.remove('selected');
                } else {
                    cell.textContent = board[r][c];
                    cell.classList.remove('empty');
                }
            });
        }
        
        function handleCellClick(r, c, cell) {
            if (!gameActive || board[r][c] === null) return;
            
            // ä¿å­˜ä¹‹å‰é€‰ä¸­çš„å•å…ƒæ ¼ä¿¡æ¯
            const prevCell = selectedCell;
            const prevR = prevCell ? parseInt(prevCell.dataset.row) : -1;
            const prevC = prevCell ? parseInt(prevCell.dataset.col) : -1;
            
            // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­æ ·å¼
            if (prevCell) {
                prevCell.classList.remove('selected');
            }
            
            // å¦‚æœç‚¹å‡»åŒä¸€ä¸ªå•å…ƒæ ¼ï¼Œå–æ¶ˆé€‰ä¸­
            if (prevR === r && prevC === c) {
                selectedCell = null;
                return;
            }
            
            // å¦‚æœå·²ç»æœ‰é€‰ä¸­çš„å•å…ƒæ ¼ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥é…å¯¹
            if (prevCell !== null) {
                // æ£€æŸ¥å›¾æ ‡æ˜¯å¦ç›¸åŒ
                if (board[prevR][prevC] === board[r][c]) {
                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥
                    const path = findPath(prevR, prevC, r, c);
                    if (path) {
                        moves++;
                        score += 10 + Math.max(0, 5 - moves);
                        updateInfo();
                        drawPath(path);
                        
                        // å»¶è¿Ÿæ¶ˆé™¤
                        setTimeout(() => {
                            eliminate(prevR, prevC, r, c);
                            selectedCell = null;
                            checkWin();
                        }, 300);
                        return;
                    } else {
                        // æ— æ³•è¿æ¥ï¼Œåˆ‡æ¢é€‰ä¸­åˆ°å½“å‰å•å…ƒæ ¼
                    }
                } else {
                    // å›¾æ ‡ä¸åŒï¼Œåˆ‡æ¢é€‰ä¸­åˆ°å½“å‰å•å…ƒæ ¼
                }
            }
            
            // é€‰ä¸­å½“å‰å•å…ƒæ ¼
            cell.classList.add('selected');
            selectedCell = cell;
        }
        
        function findPath(r1, c1, r2, c2) {
            // ç›´æ¥ç›¸è¿ï¼ˆ0 æŠ˜ï¼‰
            if (canConnectDirectly(r1, c1, r2, c2)) {
                return [{r: r1, c: c1}, {r: r2, c: c2}];
            }
            
            // ä¸€æŠ˜ç›¸è¿
            const oneTurn = findOneTurnPath(r1, c1, r2, c2);
            if (oneTurn) return oneTurn;
            
            // ä¸¤æŠ˜ç›¸è¿
            const twoTurn = findTwoTurnPath(r1, c1, r2, c2);
            if (twoTurn) return twoTurn;
            
            return null;
        }
        
        function canConnectDirectly(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            
            if (r1 === r2) {
                const min = Math.min(c1, c2);
                const max = Math.max(c1, c2);
                for (let c = min + 1; c < max; c++) {
                    if (board[r1][c] !== null) return false;
                }
                return true;
            } else {
                const min = Math.min(r1, r2);
                const max = Math.max(r1, r2);
                for (let r = min + 1; r < max; r++) {
                    if (board[r][c1] !== null) return false;
                }
                return true;
            }
        }
        
        function findOneTurnPath(r1, c1, r2, c2) {
            // å°è¯•ä¸¤ä¸ªè½¬è§’ç‚¹
            const corner1 = {r: r1, c: c2};
            const corner2 = {r: r2, c: c1};
            
            if (board[corner1.r][corner1.c] === null &&
                canConnectDirectly(r1, c1, corner1.r, corner1.c) &&
                canConnectDirectly(corner1.r, corner1.c, r2, c2)) {
                return [{r: r1, c: c1}, corner1, {r: r2, c: c2}];
            }
            
            if (board[corner2.r][corner2.c] === null &&
                canConnectDirectly(r1, c1, corner2.r, corner2.c) &&
                canConnectDirectly(corner2.r, corner2.c, r2, c2)) {
                return [{r: r1, c: c1}, corner2, {r: r2, c: c2}];
            }
            
            return null;
        }
        
        function findTwoTurnPath(r1, c1, r2, c2) {
            // ä»èµ·ç‚¹æ°´å¹³æ‰«æ
            for (let c = 0; c < cols + 2; c++) {
                if (c === c1) continue;
                if (board[r1][c] !== null) continue;
                
                // æ£€æŸ¥èƒ½å¦ä» (r1,c1) åˆ° (r1,c)
                if (!canConnectDirectly(r1, c1, r1, c)) continue;
                
                // æ£€æŸ¥èƒ½å¦ä» (r1,c) ä¸€æŠ˜åˆ°è¾¾ (r2,c2)
                const corner = {r: r2, c: c};
                if (board[corner.r][corner.c] === null &&
                    canConnectDirectly(r1, c, corner.r, corner.c) &&
                    canConnectDirectly(corner.r, corner.c, r2, c2)) {
                    return [{r: r1, c: c1}, {r: r1, c: c}, corner, {r: r2, c: c2}];
                }
            }
            
            // ä»èµ·ç‚¹å‚ç›´æ‰«æ
            for (let r = 0; r < rows + 2; r++) {
                if (r === r1) continue;
                if (board[r][c1] !== null) continue;
                
                if (!canConnectDirectly(r1, c1, r, c1)) continue;
                
                const corner = {r: r, c: c2};
                if (board[corner.r][corner.c] === null &&
                    canConnectDirectly(r, c1, corner.r, corner.c) &&
                    canConnectDirectly(corner.r, corner.c, r2, c2)) {
                    return [{r: r1, c: c1}, {r: r, c: c1}, corner, {r: r2, c: c2}];
                }
            }
            
            return null;
        }
        
        function drawPath(path) {
            const boardEl = document.getElementById('board');
            
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                // è·å–ä¸¤ä¸ªæ ¼å­çš„ DOM å…ƒç´ æ¥è®¡ç®—ç²¾ç¡®çš„ä¸­å¿ƒä½ç½®
                const cell1 = document.querySelector(`.cell[data-row='${p1.r}'][data-col='${p1.c}']`);
                const cell2 = document.querySelector(`.cell[data-row='${p2.r}'][data-col='${p2.c}']`);
                
                if (!cell1 || !cell2) continue;
                
                const rect1 = cell1.getBoundingClientRect();
                const rect2 = cell2.getBoundingClientRect();
                const boardRect = boardEl.getBoundingClientRect();
                
                // è®¡ç®—ç›¸å¯¹äºæ£‹ç›˜å®¹å™¨çš„ä¸­å¿ƒç‚¹åæ ‡
                const x1 = rect1.left - boardRect.left + rect1.width / 2;
                const y1 = rect1.top - boardRect.top + rect1.height / 2;
                const x2 = rect2.left - boardRect.left + rect2.width / 2;
                const y2 = rect2.top - boardRect.top + rect2.height / 2;
                
                const line = document.createElement('div');
                line.className = 'line';
                
                if (p1.r === p2.r) {
                    // æ°´å¹³çº¿ - ä»ä¸­å¿ƒåˆ°ä¸­å¿ƒ
                    line.style.height = '3px';
                    line.style.width = Math.abs(x2 - x1) + 'px';
                    line.style.left = Math.min(x1, x2) + 'px';
                    line.style.top = (y1 - 1.5) + 'px';
                } else {
                    // å‚ç›´çº¿ - ä»ä¸­å¿ƒåˆ°ä¸­å¿ƒ
                    line.style.width = '3px';
                    line.style.height = Math.abs(y2 - y1) + 'px';
                    line.style.left = (x1 - 1.5) + 'px';
                    line.style.top = Math.min(y1, y2) + 'px';
                }
                
                boardEl.appendChild(line);
                
                // åŠ¨ç”»ç»“æŸåç§»é™¤
                setTimeout(() => line.remove(), 500);
            }
        }
        
        function eliminate(r1, c1, r2, c2) {
            board[r1][c1] = null;
            board[r2][c2] = null;
            
            const cell1 = document.querySelector(`[data-row="${r1}"][data-col="${c1}"]`);
            const cell2 = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);
            
            cell1.classList.add('matched');
            cell2.classList.add('matched');
        }
        
        function checkWin() {
            let remaining = 0;
            for (let r = 0; r < rows + 2; r++) {
                for (let c = 0; c < cols + 2; c++) {
                    if (board[r][c] !== null) {
                        remaining++;
                        break;
                    }
                }
            }
            
            if (remaining === 0) {
                stopTimer();
                gameActive = false;
                document.getElementById('finalTime').textContent = time;
                document.getElementById('finalMoves').textContent = moves;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('winModal').classList.add('show');
            }
        }
        
        function startTimer() {
            timer = setInterval(() => {
                time++;
                updateInfo();
            }, 1000);
        }
        
        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
        }
        
        function updateInfo() {
            document.getElementById('time').textContent = time;
            document.getElementById('moves').textContent = moves;
            document.getElementById('score').textContent = score;
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        init();
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—
        window.addEventListener('resize', () => {
            // å¯ä»¥æ·»åŠ å“åº”å¼å¤„ç†é€»è¾‘
        });
    </script>
    
    <div class="footer">
        <button class="version-btn" onclick="showVersion()">ğŸ“‹ ç‰ˆæœ¬ä¿¡æ¯</button>
    </div>
</body>
</html>
