<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è¿è¿çœ‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 10px;
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .info-bar {
            display: flex;
            gap: 20px;
            justify-content: center;
            color: white;
            font-size: 1.1em;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .info-item {
            background: rgba(255,255,255,0.2);
            padding: 8px 15px;
            border-radius: 20px;
        }
        
        .game-container {
            background: white;
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            max-width: 100%;
            overflow: auto;
        }
        
        .game-board-wrapper {
            display: flex;
            justify-content: center;
        }
        
        .game-board {
            display: grid;
            gap: 2px;
            position: relative;
            width: min(90vw, 90vh, 500px);
            height: min(90vw, 90vh, 500px);
            margin: 0 auto;
        }
        
        .cell {
            background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(10px, 3vw, 20px);
            transition: all 0.2s ease;
            box-shadow: 3px 3px 6px rgba(0,0,0,0.1), -3px -3px 6px rgba(255,255,255,0.8);
        }
        
        .cell:hover {
            transform: scale(1.05);
        }
        
        .cell.selected {
            background: linear-gradient(145deg, #ffeb3b, #ffc107);
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2);
            animation: pulse 0.5s ease-in-out;
        }
        
        .cell.matched {
            opacity: 0;
            pointer-events: none;
        }
        
        .cell.empty {
            background: transparent;
            box-shadow: none;
            cursor: default;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        
        .line {
            position: absolute;
            background: #4CAF50;
            border-radius: 3px;
            z-index: 10;
            pointer-events: none;
            animation: drawLine 0.3s ease-out;
        }
        
        @keyframes drawLine {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 25px;
            font-size: 1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .btn-primary {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(145deg, #f093fb, #f5576c);
            color: white;
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .modal.show {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 90%;
            animation: popIn 0.3s ease-out;
        }
        
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        .modal-content h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 2em;
        }
        
        .modal-content p {
            color: #666;
            margin-bottom: 20px;
            font-size: 1.2em;
        }
        
        .difficulty-select {
            margin-bottom: 15px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            margin: 5px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .difficulty-btn.active,
        .difficulty-btn:hover {
            background: #667eea;
            color: white;
        }
        
        @media (max-width: 500px) {
            .header h1 {
                font-size: 1.3em;
            }
            
            .info-bar {
                font-size: 0.8em;
                gap: 10px;
            }
            
            .info-item {
                padding: 5px 10px;
                font-size: 0.9em;
            }
            
            .game-container {
                padding: 6px;
            }
            
            .btn {
                padding: 10px 20px;
                font-size: 0.9em;
            }
            
            .modal-content {
                padding: 20px;
            }
            
            .difficulty-btn {
                padding: 8px 15px;
                font-size: 0.9em;
            }
        }
        
        @media (max-width: 380px) {
            .header h1 {
                font-size: 1.1em;
            }
            
            .info-bar {
                font-size: 0.7em;
                gap: 8px;
            }
            
            .info-item {
                padding: 4px 8px;
            }
            
            .controls {
                gap: 8px;
            }
            
            .btn {
                padding: 8px 15px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ® è¿è¿çœ‹</h1>
    </div>
    
    <div class="info-bar">
        <div class="info-item">â±ï¸ æ—¶é—´ï¼š<span id="time">0</span>ç§’</div>
        <div class="info-item">ğŸ”„ æ­¥æ•°ï¼š<span id="moves">0</span></div>
        <div class="info-item">ğŸ’¯ åˆ†æ•°ï¼š<span id="score">0</span></div>
    </div>
    
    <div class="game-container">
        <div class="game-board-wrapper">
            <div class="game-board" id="board"></div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn btn-primary" onclick="showNewGameModal()">ğŸ”„ æ–°æ¸¸æˆ</button>
        <button class="btn btn-secondary" onclick="shuffleBoard()">ğŸ”€ æ‰“ä¹±</button>
    </div>
    
    <div class="modal" id="winModal">
        <div class="modal-content">
            <h2>ğŸ‰ æ­å–œè·èƒœï¼</h2>
            <p>ç”¨æ—¶ï¼š<span id="finalTime">0</span>ç§’<br>æ­¥æ•°ï¼š<span id="finalMoves">0</span><br>å¾—åˆ†ï¼š<span id="finalScore">0</span></p>
            <button class="btn btn-primary" onclick="closeModal(); startNewGame()">å†ç©ä¸€æ¬¡</button>
        </div>
    </div>
    
    <div class="modal" id="newGameModal">
        <div class="modal-content">
            <h2>ğŸ® æ–°æ¸¸æˆ</h2>
            <div class="difficulty-select">
                <button class="difficulty-btn active" onclick="setDifficulty('easy')">ç®€å•</button>
                <button class="difficulty-btn" onclick="setDifficulty('medium')">ä¸­ç­‰</button>
                <button class="difficulty-btn" onclick="setDifficulty('hard')">å›°éš¾</button>
            </div>
            <button class="btn btn-primary" onclick="confirmNewGame()">å¼€å§‹æ¸¸æˆ</button>
        </div>
    </div>

    <script>
        const emojis = ['ğŸ', 'ğŸŠ', 'ğŸ‹', 'ğŸŒ', 'ğŸ‰', 'ğŸ‡', 'ğŸ“', 'ğŸ«', 'ğŸ’', 'ğŸ‘', 'ğŸ¥­', 'ğŸ', 'ğŸ¥¥', 'ğŸ¥', 'ğŸ…', 'ğŸ¥‘'];
        
        let board = [];
        let rows = 8;
        let cols = 8;
        let selectedCell = null;
        let time = 0;
        let moves = 0;
        let score = 0;
        let timer = null;
        let gameActive = false;
        let currentDifficulty = 'easy';
        
        const difficultySettings = {
            easy: { rows: 4, cols: 6 },
            medium: { rows: 6, cols: 8 },
            hard: { rows: 8, cols: 10 }
        };
        
        function init() {
            createBoard();
            startTimer();
            gameActive = true;
        }
        
        function showNewGameModal() {
            document.getElementById('newGameModal').classList.add('show');
        }
        
        function setDifficulty(level) {
            currentDifficulty = level;
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent === (level === 'easy' ? 'ç®€å•' : level === 'medium' ? 'ä¸­ç­‰' : 'å›°éš¾')) {
                    btn.classList.add('active');
                }
            });
        }
        
        function confirmNewGame() {
            document.getElementById('newGameModal').classList.remove('show');
            startNewGame();
        }
        
        function closeModal() {
            document.getElementById('winModal').classList.remove('show');
        }
        
        function startNewGame() {
            stopTimer();
            const settings = difficultySettings[currentDifficulty];
            rows = settings.rows;
            cols = settings.cols;
            board = [];
            selectedCell = null;
            time = 0;
            moves = 0;
            score = 0;
            updateInfo();
            createBoard();
            startTimer();
            gameActive = true;
        }
        
        function createBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            boardEl.style.gridTemplateColumns = `repeat(${cols + 2}, 1fr)`;
            
            // åˆå§‹åŒ–ç©ºæ£‹ç›˜ï¼ˆè¾¹ç•Œä¸ºç©ºï¼‰
            for (let r = 0; r < rows + 2; r++) {
                board[r] = [];
                for (let c = 0; c < cols + 2; c++) {
                    board[r][c] = null;
                }
            }
            
            // è®¡ç®—å¯æ”¾ç½®çš„ä½ç½®ï¼ˆä¸åŒ…æ‹¬è¾¹ç•Œï¼‰
            let positions = [];
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    positions.push({r, c});
                }
            }
            
            // æ‰“ä¹±ä½ç½®
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }
            
            // æˆå¯¹æ”¾ç½®å›¾æ ‡ï¼Œç¡®ä¿æ¯å¯¹éƒ½èƒ½è¿æ¥
            let pairCount = 0;
            const maxPairs = Math.floor(positions.length / 2);
            
            while (pairCount < maxPairs) {
                // é€‰æ‹©ä¸¤ä¸ªç›¸é‚»çš„ç©ºä½ç½®
                let placed = false;
                for (let attempt = 0; attempt < 100 && !placed; attempt++) {
                    const idx1 = Math.floor(Math.random() * positions.length);
                    const pos1 = positions[idx1];
                    
                    // æ£€æŸ¥è¿™ä¸ªä½ç½®æ˜¯å¦å·²ç»å¡«å……
                    if (board[pos1.r][pos1.c] !== null) continue;
                    
                    // æ‰¾åˆ°ç›¸é‚»çš„ç©ºä½ç½®
                    const neighbors = [
                        {r: pos1.r - 1, c: pos1.c},
                        {r: pos1.r + 1, c: pos1.c},
                        {r: pos1.r, c: pos1.c - 1},
                        {r: pos1.r, c: pos1.c + 1}
                    ];
                    
                    for (const pos2 of neighbors) {
                        // æ£€æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…ä¸”ä¸ºç©º
                        if (pos2.r >= 1 && pos2.r <= rows && 
                            pos2.c >= 1 && pos2.c <= cols &&
                            board[pos2.r][pos2.c] === null) {
                            
                            // æ”¾ç½®ä¸€å¯¹å›¾æ ‡
                            const emoji = emojis[pairCount % emojis.length];
                            board[pos1.r][pos1.c] = emoji;
                            board[pos2.r][pos2.c] = emoji;
                            pairCount++;
                            placed = true;
                            break;
                        }
                    }
                }
                
                if (!placed) {
                    // å¦‚æœå°è¯•å¤šæ¬¡éƒ½æ— æ³•æ”¾ç½®ï¼Œå°è¯•ä»»æ„ä¸¤ä¸ªç©ºä½
                    let emptyPositions = positions.filter(p => board[p.r][p.c] === null);
                    if (emptyPositions.length >= 2) {
                        const idx1 = Math.floor(Math.random() * emptyPositions.length);
                        const idx2 = Math.floor(Math.random() * emptyPositions.length);
                        if (idx1 !== idx2) {
                            const emoji = emojis[pairCount % emojis.length];
                            board[emptyPositions[idx1].r][emptyPositions[idx1].c] = emoji;
                            board[emptyPositions[idx2].r][emptyPositions[idx2].c] = emoji;
                            pairCount++;
                        } else {
                            break;
                        }
                    } else {
                        break;
                    }
                }
            }
            
            // æ¸²æŸ“æ£‹ç›˜
            for (let r = 0; r < rows + 2; r++) {
                for (let c = 0; c < cols + 2; c++) {
                    const cell = document.createElement('button');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    if (board[r][c] === null) {
                        cell.classList.add('empty');
                    } else {
                        cell.textContent = board[r][c];
                        cell.onclick = () => handleCellClick(r, c, cell);
                    }
                    
                    boardEl.appendChild(cell);
                }
            }
        }
        
        function shuffleBoard() {
            if (!gameActive) return;
            
            // æ”¶é›†æ‰€æœ‰å‰©ä½™çš„å›¾æ ‡å’Œç©ºä½ç½®
            let remainingIcons = [];
            let emptyPositions = [];
            
            for (let r = 0; r < rows + 2; r++) {
                for (let c = 0; c < cols + 2; c++) {
                    if (board[r][c] !== null) {
                        remainingIcons.push(board[r][c]);
                    } else if (r >= 1 && r <= rows && c >= 1 && c <= cols) {
                        emptyPositions.push({r, c});
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰å‰©ä½™å›¾æ ‡æˆ–æ— æ³•é…å¯¹ï¼Œç›´æ¥è¿”å›
            if (remainingIcons.length < 2 || remainingIcons.length % 2 !== 0) {
                return;
            }
            
            // æ¸…ç©ºä¸­é—´åŒºåŸŸ
            for (let r = 1; r <= rows; r++) {
                for (let c = 1; c <= cols; c++) {
                    board[r][c] = null;
                }
            }
            
            // é‡æ–°æˆå¯¹æ”¾ç½®å›¾æ ‡
            let pairIdx = 0;
            const totalPairs = remainingIcons.length / 2;
            
            while (pairIdx < totalPairs) {
                let placed = false;
                
                // å°è¯•æ‰¾åˆ°ä¸¤ä¸ªç›¸é‚»çš„ç©ºä½ç½®
                for (let attempt = 0; attempt < 50 && !placed; attempt++) {
                    for (let r = 1; r <= rows; r++) {
                        for (let c = 1; c <= cols; c++) {
                            if (board[r][c] !== null) continue;
                            
                            const neighbors = [
                                {r: r - 1, c: c},
                                {r: r + 1, c: c},
                                {r: r, c: c - 1},
                                {r: r, c: c + 1}
                            ];
                            
                            for (const pos of neighbors) {
                                if (pos.r >= 1 && pos.r <= rows && 
                                    pos.c >= 1 && pos.c <= cols &&
                                    board[pos.r][pos.c] === null) {
                                    
                                    const emoji = remainingIcons[pairIdx * 2];
                                    board[r][c] = emoji;
                                    board[pos.r][pos.c] = emoji;
                                    pairIdx++;
                                    placed = true;
                                    break;
                                }
                            }
                            if (placed) break;
                        }
                        if (placed) break;
                    }
                }
                
                if (!placed) {
                    // å¦‚æœæ— æ³•æ‰¾åˆ°ç›¸é‚»ä½ç½®ï¼Œä»»æ„æ”¾ç½®å‰©ä½™å›¾æ ‡
                    let emptyCells = [];
                    for (let r = 1; r <= rows; r++) {
                        for (let c = 1; c <= cols; c++) {
                            if (board[r][c] === null) {
                                emptyCells.push({r, c});
                            }
                        }
                    }
                    
                    while (emptyCells.length >= 2 && pairIdx < totalPairs) {
                        const pos1 = emptyCells.shift();
                        const pos2 = emptyCells.shift();
                        const emoji = remainingIcons[pairIdx * 2];
                        board[pos1.r][pos1.c] = emoji;
                        board[pos2.r][pos2.c] = emoji;
                        pairIdx++;
                    }
                    break;
                }
            }
            
            // æ›´æ–°æ˜¾ç¤º
            renderBoard();
            selectedCell = null;
        }
        
        function renderBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                
                if (board[r][c] === null) {
                    cell.textContent = '';
                    cell.classList.add('empty');
                    cell.classList.remove('selected');
                } else {
                    cell.textContent = board[r][c];
                    cell.classList.remove('empty');
                }
            });
        }
        
        function handleCellClick(r, c, cell) {
            if (!gameActive || board[r][c] === null) return;
            
            // ä¿å­˜ä¹‹å‰é€‰ä¸­çš„å•å…ƒæ ¼ä¿¡æ¯
            const prevCell = selectedCell;
            const prevR = prevCell ? parseInt(prevCell.dataset.row) : -1;
            const prevC = prevCell ? parseInt(prevCell.dataset.col) : -1;
            
            // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­æ ·å¼
            if (prevCell) {
                prevCell.classList.remove('selected');
            }
            
            // å¦‚æœç‚¹å‡»åŒä¸€ä¸ªå•å…ƒæ ¼ï¼Œå–æ¶ˆé€‰ä¸­
            if (prevR === r && prevC === c) {
                selectedCell = null;
                return;
            }
            
            // å¦‚æœå·²ç»æœ‰é€‰ä¸­çš„å•å…ƒæ ¼ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥é…å¯¹
            if (prevCell !== null) {
                // æ£€æŸ¥å›¾æ ‡æ˜¯å¦ç›¸åŒ
                if (board[prevR][prevC] === board[r][c]) {
                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿æ¥
                    const path = findPath(prevR, prevC, r, c);
                    if (path) {
                        moves++;
                        score += 10 + Math.max(0, 5 - moves);
                        updateInfo();
                        drawPath(path);
                        
                        // å»¶è¿Ÿæ¶ˆé™¤
                        setTimeout(() => {
                            eliminate(prevR, prevC, r, c);
                            selectedCell = null;
                            checkWin();
                        }, 300);
                        return;
                    } else {
                        // æ— æ³•è¿æ¥ï¼Œåˆ‡æ¢é€‰ä¸­åˆ°å½“å‰å•å…ƒæ ¼
                    }
                } else {
                    // å›¾æ ‡ä¸åŒï¼Œåˆ‡æ¢é€‰ä¸­åˆ°å½“å‰å•å…ƒæ ¼
                }
            }
            
            // é€‰ä¸­å½“å‰å•å…ƒæ ¼
            cell.classList.add('selected');
            selectedCell = cell;
        }
        
        function findPath(r1, c1, r2, c2) {
            // ç›´æ¥ç›¸è¿ï¼ˆ0 æŠ˜ï¼‰
            if (canConnectDirectly(r1, c1, r2, c2)) {
                return [{r: r1, c: c1}, {r: r2, c: c2}];
            }
            
            // ä¸€æŠ˜ç›¸è¿
            const oneTurn = findOneTurnPath(r1, c1, r2, c2);
            if (oneTurn) return oneTurn;
            
            // ä¸¤æŠ˜ç›¸è¿
            const twoTurn = findTwoTurnPath(r1, c1, r2, c2);
            if (twoTurn) return twoTurn;
            
            return null;
        }
        
        function canConnectDirectly(r1, c1, r2, c2) {
            if (r1 !== r2 && c1 !== c2) return false;
            
            if (r1 === r2) {
                const min = Math.min(c1, c2);
                const max = Math.max(c1, c2);
                for (let c = min + 1; c < max; c++) {
                    if (board[r1][c] !== null) return false;
                }
                return true;
            } else {
                const min = Math.min(r1, r2);
                const max = Math.max(r1, r2);
                for (let r = min + 1; r < max; r++) {
                    if (board[r][c1] !== null) return false;
                }
                return true;
            }
        }
        
        function findOneTurnPath(r1, c1, r2, c2) {
            // å°è¯•ä¸¤ä¸ªè½¬è§’ç‚¹
            const corner1 = {r: r1, c: c2};
            const corner2 = {r: r2, c: c1};
            
            if (board[corner1.r][corner1.c] === null &&
                canConnectDirectly(r1, c1, corner1.r, corner1.c) &&
                canConnectDirectly(corner1.r, corner1.c, r2, c2)) {
                return [{r: r1, c: c1}, corner1, {r: r2, c: c2}];
            }
            
            if (board[corner2.r][corner2.c] === null &&
                canConnectDirectly(r1, c1, corner2.r, corner2.c) &&
                canConnectDirectly(corner2.r, corner2.c, r2, c2)) {
                return [{r: r1, c: c1}, corner2, {r: r2, c: c2}];
            }
            
            return null;
        }
        
        function findTwoTurnPath(r1, c1, r2, c2) {
            // ä»èµ·ç‚¹æ°´å¹³æ‰«æ
            for (let c = 0; c < cols + 2; c++) {
                if (c === c1) continue;
                if (board[r1][c] !== null) continue;
                
                // æ£€æŸ¥èƒ½å¦ä» (r1,c1) åˆ° (r1,c)
                if (!canConnectDirectly(r1, c1, r1, c)) continue;
                
                // æ£€æŸ¥èƒ½å¦ä» (r1,c) ä¸€æŠ˜åˆ°è¾¾ (r2,c2)
                const corner = {r: r2, c: c};
                if (board[corner.r][corner.c] === null &&
                    canConnectDirectly(r1, c, corner.r, corner.c) &&
                    canConnectDirectly(corner.r, corner.c, r2, c2)) {
                    return [{r: r1, c: c1}, {r: r1, c: c}, corner, {r: r2, c: c2}];
                }
            }
            
            // ä»èµ·ç‚¹å‚ç›´æ‰«æ
            for (let r = 0; r < rows + 2; r++) {
                if (r === r1) continue;
                if (board[r][c1] !== null) continue;
                
                if (!canConnectDirectly(r1, c1, r, c1)) continue;
                
                const corner = {r: r, c: c2};
                if (board[corner.r][corner.c] === null &&
                    canConnectDirectly(r, c1, corner.r, corner.c) &&
                    canConnectDirectly(corner.r, corner.c, r2, c2)) {
                    return [{r: r1, c: c1}, {r: r, c: c1}, corner, {r: r2, c: c2}];
                }
            }
            
            return null;
        }
        
        function drawPath(path) {
            const boardEl = document.getElementById('board');
            const cellWidth = boardEl.offsetWidth / (cols + 2);
            const cellHeight = boardEl.offsetHeight / (rows + 2);
            
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                const line = document.createElement('div');
                line.className = 'line';
                
                const x1 = p1.c * cellWidth + cellWidth / 2;
                const y1 = p1.r * cellHeight + cellHeight / 2;
                const x2 = p2.c * cellWidth + cellWidth / 2;
                const y2 = p2.r * cellHeight + cellHeight / 2;
                
                if (p1.r === p2.r) {
                    // æ°´å¹³çº¿
                    line.style.height = '4px';
                    line.style.width = Math.abs(x2 - x1) + 'px';
                    line.style.left = Math.min(x1, x2) + 'px';
                    line.style.top = (y1 - 2) + 'px';
                } else {
                    // å‚ç›´çº¿
                    line.style.width = '4px';
                    line.style.height = Math.abs(y2 - y1) + 'px';
                    line.style.left = (x1 - 2) + 'px';
                    line.style.top = Math.min(y1, y2) + 'px';
                }
                
                boardEl.appendChild(line);
                
                // åŠ¨ç”»ç»“æŸåç§»é™¤
                setTimeout(() => line.remove(), 500);
            }
        }
        
        function eliminate(r1, c1, r2, c2) {
            board[r1][c1] = null;
            board[r2][c2] = null;
            
            const cell1 = document.querySelector(`[data-row="${r1}"][data-col="${c1}"]`);
            const cell2 = document.querySelector(`[data-row="${r2}"][data-col="${c2}"]`);
            
            cell1.classList.add('matched');
            cell2.classList.add('matched');
        }
        
        function checkWin() {
            let remaining = 0;
            for (let r = 0; r < rows + 2; r++) {
                for (let c = 0; c < cols + 2; c++) {
                    if (board[r][c] !== null) {
                        remaining++;
                        break;
                    }
                }
            }
            
            if (remaining === 0) {
                stopTimer();
                gameActive = false;
                document.getElementById('finalTime').textContent = time;
                document.getElementById('finalMoves').textContent = moves;
                document.getElementById('finalScore').textContent = score;
                document.getElementById('winModal').classList.add('show');
            }
        }
        
        function startTimer() {
            timer = setInterval(() => {
                time++;
                updateInfo();
            }, 1000);
        }
        
        function stopTimer() {
            if (timer) {
                clearInterval(timer);
                timer = null;
            }
        }
        
        function updateInfo() {
            document.getElementById('time').textContent = time;
            document.getElementById('moves').textContent = moves;
            document.getElementById('score').textContent = score;
        }
        
        // åˆå§‹åŒ–æ¸¸æˆ
        init();
        
        // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—
        window.addEventListener('resize', () => {
            // å¯ä»¥æ·»åŠ å“åº”å¼å¤„ç†é€»è¾‘
        });
    </script>
</body>
</html>
